<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [3 词法分析](#3-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90)
  - [3.1 词法分析器的作用](#31-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8)
  - [3.2 输入缓冲](#32-%E8%BE%93%E5%85%A5%E7%BC%93%E5%86%B2)
  - [3.3 词法单元规约](#33-%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83%E8%A7%84%E7%BA%A6)
  - [3.4 词法单元的识别](#34-%E8%AF%8D%E6%B3%95%E5%8D%95%E5%85%83%E7%9A%84%E8%AF%86%E5%88%AB)
  - [3.5 词法分析器生成工具Lex](#35-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7lex)
  - [3.6 有穷自动机](#36-%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA)
    - [不确定有穷自动机](#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA)
    - [确定有穷自动机](#%E7%A1%AE%E5%AE%9A%E6%9C%89%E7%A9%B7%E8%87%AA%E5%8A%A8%E6%9C%BA)
  - [3.7 从正则表达式到自动机](#37-%E4%BB%8E%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%B0%E8%87%AA%E5%8A%A8%E6%9C%BA)
  - [3.8 词法分析器生成工具的设计](#38-%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%94%9F%E6%88%90%E5%B7%A5%E5%85%B7%E7%9A%84%E8%AE%BE%E8%AE%A1)
  - [3.9 基于DFA的模式匹配器的优化](#39-%E5%9F%BA%E4%BA%8Edfa%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E5%99%A8%E7%9A%84%E4%BC%98%E5%8C%96)
    - [1、如何将一个正则表达式直接构造的到DFA](#1%E5%A6%82%E4%BD%95%E5%B0%86%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9B%B4%E6%8E%A5%E6%9E%84%E9%80%A0%E7%9A%84%E5%88%B0dfa)
    - [2、如何高效地将任何DFA中具有相同未来行为的多个状态合并，使DFA的状态数量减到最少](#2%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%9C%B0%E5%B0%86%E4%BB%BB%E4%BD%95dfa%E4%B8%AD%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E6%9C%AA%E6%9D%A5%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%8A%B6%E6%80%81%E5%90%88%E5%B9%B6%E4%BD%BFdfa%E7%9A%84%E7%8A%B6%E6%80%81%E6%95%B0%E9%87%8F%E5%87%8F%E5%88%B0%E6%9C%80%E5%B0%91)
    - [3、如何生成比标准二维表更加紧凑的转换表的表示方式](#3%E5%A6%82%E4%BD%95%E7%94%9F%E6%88%90%E6%AF%94%E6%A0%87%E5%87%86%E4%BA%8C%E7%BB%B4%E8%A1%A8%E6%9B%B4%E5%8A%A0%E7%B4%A7%E5%87%91%E7%9A%84%E8%BD%AC%E6%8D%A2%E8%A1%A8%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 3 词法分析

## 3.1 词法分析器的作用
词法分析器与语法分析器之间的交互



![词法分析器和语法分析器之间的交互](./images/Pasted%20image%2020230101234019.png){width=50%}



词法分析器完成的任务：

1. 过滤掉程序中的注释和空白（空格、换行符、制表符以及在输入中用于分隔词法单元的其他字符）；
2. 将编译器生成的错误信息与源程序的位置联系起来。

词法分析器的两个处理阶段：
1. 扫描阶段：主要负责完成一些不需要生成词法单元的简单处理，比如删除注释和将多个连续的空白字符压缩成一个字符；
2. 词法分析阶段：处理扫描阶段的输出并生成词法单元。

把编译过程的分析部分划分为 【词法分析】 和 【语法分析】 阶段的三个原因：
1. 简化编译器的设计；
2. 提高编译器的效率；
3. 增强编译器的可移植性。

词法单元、模式和词素定义：
1. 词法单元：由一个词法单元名和一个可选的属性值组成；
2. 模式：描述了一个词法单元的词素可能具有的形式，当词法单元是一个关键字时，它的模式就是组成这个关键字的字符序列；
3. 词素：源程序中的一个字符序列，它和某个词法单元的模式匹配，并被词法分析器识别为该词法单元的一个实例。
比如词法单元时`comparison`，词素可以是`<=, !=`

## 3.2 输入缓冲

编译一个大型源程序时需要处理大量字符，处理这些字符需要很多的时间。
解决方案就是使用一种重要的机制：利用两个交替读入的缓冲区。
一般每个缓冲区的容量都是N个字符，通常N时一个磁盘块的大小，如4096字节。一般系统读取命令一次将N个字符读入到缓冲区，若输入文件中的剩余字符不足N个，那么就会有一个特殊字符（用eof表示，不会出现在源程序中）来表示文件的结束。

哨兵标记：
每个缓冲区末端都会设置一个`eof`，因此每读入一个字符都需要做两次测试：
1. 检查是否到达缓冲区的末尾；
2. 确定读入的字符时什么。

## 3.3 词法单元规约
正则表达式是一种用来描述词素模式的重要表示方法。
这一节介绍了比较多正则表达式相关的知识

##  3.4 词法单元的识别

介绍了状态转换图，状态转化图由一些节点和单向边组成。
节点：包含开始状态、接受状态、最终状态，最终状态一般由两个圈圈表示
边：由一个状态指向另一个状态，每条边的标号包含了一个符号

提到了KMP算法



![KMP算法的关键](./images/Pasted%20image%2020230101221044.png){width=80%}

KMP算法的核心就是这个失效匹配数组。
关键就是利用前缀和后缀为pattern构建这个是失效匹配数组（失效函数）。
具体可以见：[(8 封私信) 如何更好地理解和掌握 KMP 算法? - 知乎 (zhihu.com)](https://www.zhihu.com/question/21923021)

## 3.5 词法分析器生成工具Lex
Lex工具的输入表示方法称为Lex语言，而工具本身称为Lex编译器。在它的核心部分，Lex编译器将输入的模式转换成一个状态转换图，并生成相应的实现代码，并存放到文件lex.yy.c中

用Lex创建一个词法分析器



![用Lex创建一个词法分析器](./images/Pasted%20image%2020230101234154.png){width=50%}

## 3.6 有穷自动机
Lex将输入程序编程一个词法分析器，转换的核心是有穷自动机。
有穷自动机可以分为两类：
1. 不确定的有穷自动机（NFA）；
2. 确定的有穷自动机（DFA）。

### 不确定有穷自动机

![不确定有穷自动机](./images/Pasted%20image%2020230101234128.png){width=50%}

上面这个为什么叫做不确定有穷自动机呢，因为在状态0时，如果读取到一个字符a，不能确定下一个状态是0还是1，还要继续往下继续读取。

### 确定有穷自动机
确定的有穷自动机是不确定有穷自动机的一个特例，其中：
1. 没有输入$\epsilon$ 之上的转换动作；
2. 对每个状态s和每个输入符号a，有且只有一条标号为a的边离开s。

## 3.7 从正则表达式到自动机
这一节的核心内容就是介绍了
正则表达式 转换为 NFA 再转换到 DFA相关的算法
NFA -> DFA的过程是对NFA中的状态进行整合和压缩的一个过程，这个过程中去除了$\epsilon$相关的边
可以参考
[NFA到DFA的转化_风起云涌2021的博客-CSDN博客_nfa转化为dfa](https://blog.csdn.net/u012359618/article/details/42456771)
[NFA到DFA的转换及DFA的简化_爱玩游戏的小隐的博客-CSDN博客_nfa转换dfa](https://blog.csdn.net/qq_40294512/article/details/89004777)

加入正则表达式为r，将正则表达式r转换到NFA的时间复杂度是$O(r)$，转换到DFA的时间复杂度是$O(r^3$)，但是每个串做匹配时，每个串（假设为x）的匹配开销，用NFA是$O(|r|*|x|)$，DFA是$O(|x|)$ 因此，在x较短时，将正则表达式转化到NFA是比较合适的，否则建议转化到DFA

## 3.8 词法分析器生成工具的设计
pass

## 3.9 基于DFA的模式匹配器的优化
解决这节内容下面的三个问题首先需要了解一下 抽象语法树T
语法树的叶子结点对应于运算分量，内部结点表示运算符。
内部结点可以有下面几类：
cat结点：标号为连接运算符（o)
or结点：标号为并运算符（|）
star结点：标号为星号运算符（\*）
语法树的叶子结点可以是$\epsilon$，也可以用字母表中的符号作为标号。对于每一个标号不为$\epsilon$的叶子结点，我们赋予一个独有的整数。
![(a|b)*abb#对应的抽象语法树](./images/Pasted%20image%2020230101230910.png){width=60%}

了解了语法树，还需要再计算下面四个函数：
1. nullable(n)：对于一个语法树结点n为真当且仅当此结点代表的子表达式的语言中包含空串$\epsilon$；
2. firstpos(n)：定义了以结点n为根的子树中的位置集合。这些位置对应于以n为根的子表达式的语言中某个串的第一个符号，上图中firstpos(n) = {1, 2, 3}；
3. lastpos(n)：定义了以结点n为根的子树中的位置集合。这些位置对应于以n为根的子表达式的语言中某个串的最后一个符号。上图中lastpost(n) = {3}，也就是说，不管结点n的表达式生成什么串，该串的最后一个位置总是来自位置3上的a；
4. followpos(p)：定义了一个和位置p相关的、语法树中的某些位置的集合。上图中followpos(1) = {1, 2, 3}，因为当前的a来自1结点，那么下一个位置，可以跟随统一表达式`(a|b)*`生成的a或b，此时下一个位置来自1或2，也可能当前的a是表达式`(a|b)*`生成的串的最后一个字符，那么下一个字符一定来自3。


### 1、如何将一个正则表达式直接构造的到DFA
1. 根据扩展的正则表达式$(r)\#$ 构造出一棵语法树T；
2. 计算得到T的函数nullable、firstpos、lastpos和followpos；
3. 构造状态集Dstates和转换函数Dtran。D的状态集就是T中的位置集合，每个状态最初都是“未标记的”，当我们开始考虑某个状态的离开状态时，该状态变为“已标记的”。D的开始状态是$firstpos(n_0)$，其中结点$n_0$是T的根结点。这个DFA的接受状态集合是那些包含了结束标记#对应的位置的状态。
算法如下：
```
初始化Dstates，使之只包含未标记的状态firstpos(n_0)
其中n_0是(r)#的语法树的根结点

while (Dstates中存在微标记的状态S) {
	标记S;
	for (每个输入符号a) {
		令U为S中和a对应的所有位置p的followpos(p)的并集;
		if (U不在Dstates中)
			将U作为未标记的状态加入到Dstates中;
		Dtran[S, a] = U;
	}
}
```

### 2、如何高效地将任何DFA中具有相同未来行为的多个状态合并，使DFA的状态数量减到最少
![如何最小化DFA状态01](./images/Pasted%20image%2020230101233359.png){width=40%}



![如何最小化DFA状态02](./images/Pasted%20image%2020230101233616.png){width=40%}

### 3、如何生成比标准二维表更加紧凑的转换表的表示方式

？后面再看下，没读懂



