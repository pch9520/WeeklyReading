<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [6 中间代码生成](#6-%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90)
  - [6.1 语法树的变体](#61-%E8%AF%AD%E6%B3%95%E6%A0%91%E7%9A%84%E5%8F%98%E4%BD%93)
  - [6.2 三地址代码](#62-%E4%B8%89%E5%9C%B0%E5%9D%80%E4%BB%A3%E7%A0%81)
    - [四元式表示](#%E5%9B%9B%E5%85%83%E5%BC%8F%E8%A1%A8%E7%A4%BA)
    - [三元式表示](#%E4%B8%89%E5%85%83%E5%BC%8F%E8%A1%A8%E7%A4%BA)
  - [6.3 类型和声明](#63-%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A3%B0%E6%98%8E)
    - [类型等价](#%E7%B1%BB%E5%9E%8B%E7%AD%89%E4%BB%B7)
    - [局部变量名的存储布局](#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%90%8D%E7%9A%84%E5%AD%98%E5%82%A8%E5%B8%83%E5%B1%80)
  - [6.5 类型检查](#65-%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5)
  - [6.6 控制流](#66-%E6%8E%A7%E5%88%B6%E6%B5%81)
    - [短路代码](#%E7%9F%AD%E8%B7%AF%E4%BB%A3%E7%A0%81)
  - [6.7 回填](#67-%E5%9B%9E%E5%A1%AB)
    - [背景](#%E8%83%8C%E6%99%AF)
    - [步骤](#%E6%AD%A5%E9%AA%A4)
  - [6.8 switch语句](#68-switch%E8%AF%AD%E5%8F%A5)
  - [6.9 过程的中间代码](#69-%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BB%A3%E7%A0%81)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 6 中间代码生成

本章介绍的中间代码主要包括抽象语法树和三地址代码。

![一系列中间表示](./images/Pasted%20image%2020230129195620.png){width=60%}

低层的表示形式用于及其相关的处理任务，比如寄存器分配、指令选择等。
通过选择不同的运算符，三地址代码既可以是高层的表示方式，也可以是低层的表示方式。

不同的编译器对中间表示的选择和设计各有不同，中间表示可以是一种真正的语言，也可以由编译器的各个处理阶段共享的多个内部数据结构组成。
早期C++编译器的前端生成C代码，而把C编译器作为其后端

## 6.1 语法树的变体
为表达式构建的无环有向图（DAG）指出了表达式中的公共子表达式。我们可以用构造语法树的技术去构造DAG。
比如为下面的表达式构造DAG：
$a + a * (b - c) + (b - c) * d$

![表达式a + a * (b - c) + (b - c) * d的DAG](./images/Pasted%20image%2020230129200639.png){width=60%}


## 6.2 三地址代码
在三地址代码中，一条指令的右侧最多有一个运算符。
DAG图6-3对应的三地址代码序列可表示为：

```C
t1 = b - c;
t2 = a * t1;
t3 = a + t2;
t4 = t1 * d;
t5 = t3 + t4;
```

三地址代码的两个基本概念：地址和指令。
地址可以具有如下形式之一：
1. 名字；
2. 常量；
3. 编译器生成的临时变量。

常见的三地址指令形式：
1. x = y op z;
2. x = op y;
3. x = y;
4. goto L;
5. if x goto L或if False x goto L;
6. if x relop y goto L;
7. param x1; y = call p;
8. x = y[i];
9. x = &y; x = \*y; \*x = y;

### 四元式表示
一个四元式有四个字段，我们分别称为op、arg1、arg2、result
赋值语句 `a = b * -c + b * -c`的三地址代码及四元式如下图所示

![三地址代码及四元式表示](./images/Pasted%20image%2020230129210516.png){width=60%}

### 三元式表示
一个三元式只有三个字段，我们分别称之为op、arg1、arg2。四元式中的result字段主要被用于临时变量名。使用三元式时，我们将用`x op y`的位置来表示它的结果，而不是用一个显式的临时名字表示。例如，在三元式表示中将直接用位置(0)而不是像图6-10b中用临时名字$t_1$来表示对相应运算结果的引用。

间接三元式包含了一个指向三元式的指针的列表，而不是列出三元式序列本身。我们可以使用数组instruction按照适当的顺序列出三元式的指针。

![三地址代码的间接三元式表示](Pasted%20image%2020230129211646.png){width=60%}

## 6.3 类型和声明
类型的应用可以划分为类型检查和翻译
- 类型检查，用于保证运算分量的类型和运算符的预期类型相匹配。例如，Java要求&&运算符的两个运算分量必须是boolean型。如果满足这个条件，结果也具有boolean型。
- 翻译时的应用，根据一个名字的类型，编译器可以确定这个名字在运行时刻需要多大的存储空间。

类型表达式的定义：
- 基本类型是一个类型表达式；
- 类名是一个类型表达式；
- 将类型构造算子array作用于一个数字和一个类型表达式可以得到一个类型表达式；
- 一个记录是包含有名字段的数据结构。将record类型构造算子应用于字段名和相应的类型可以构造得到一个类型表达式；
- 使用类型构造算子 -> 可以构造得到函数类型的类型表达式；
- 如果s 和 t是类型表达式，那么笛卡尔积$s * t$也是类型表达式；
- 类型表达式可以包含取值为类型表达式的变量。

### 类型等价
当用图来表示类型表达式的时候，两种类型之间结构等价当且仅当下面某个条件为真：
- 它们是相同的基本类型；
- 它们是将相同的类型构造算子应用于结构等价的类型而构造得到；
- 一个类型是另一个类型表达式的名字。

### 局部变量名的存储布局
从变量类型我们可以知道该变量在运行时刻需要的内存数量。对于字符串这样的变长数据，以及动态数组这样的只有在运行时刻才能够确定其大小的数据，处理的方法是为指向这些数据的指针保留一个已知的固定大小的存储区域。

## 6.5 类型检查
为进行类型检查，编译器需要给源程序的每一个组成部分赋予一个类型表达式。
类型检查可以发现程序中的错误，也可以用于提高系统的安全性，使得人们安全地导入和执行软件模块。
Java程序被编译称为机器无关的字节码，在字节码中包含了有关字节码中的运算的详细类型信息。导入的代码在被执行之前首先要进行类型检查，以防止因疏忽造成的错误和恶意攻击。

## 6.6 控制流
指对if-else语句、while语句这类语句的翻译。
### 短路代码
在短路（跳转）代码中，布尔运算符&&、||和!被翻译成跳转指令。运算符本身不出现在代码中，布尔表达式的值是通过代码序列中的位置来表示的。
语句`if (x < 100 | x > 200 && x != y) x = 0;`可被翻译为下面这段跳转代码：
![跳转代码](./images/Pasted%20image%2020230129221618.png){width=60%}

## 6.7 回填
### 背景
对于`if (B) S`中的布尔表达式B的翻译结果中包含一条跳转指令。当B为假时，该指令将跳转到紧跟在S的代码之后的指令处。那么跳过S的goto指令的目标时什么？
1. 可以通过将标号作为继承属性传递到生成相关跳转指令的地方。但是，这样的做法要求再进行一趟处理，将标号和具体地址绑定起来。
2. 采用回填的补充性技术，把一个由跳转指令组成的列表以综合属性的形式进行传递。明确地讲，生成一个跳转指令时暂时不指定该跳转指令的目标，这样的指令都被放入一个由跳转指令组成的列表中。等到能够确定正确的目标标号时才去填充这些指令的目标标号。同一个列表中的所有跳转指令具有相同的目标标号。

跳转指令组成的列表，需要用到三个函数：
- makelist(i)，创建一个只包含i的列表。这里i是指令数组的下标。函数makelist返回一个指向新创建的列表的指针；
- merge(p1, p2)，将p1和p2指向的列表进行合并，它返回的指针指向合并后的列表；
- backpatch(p, i)，将i作为目标标号插入到p所指列表中的各指令中。

### 步骤
对于表达式`if (x < 100 | x > 200 && x != y) x = 0;`


![回填步骤](./images/Pasted%20image%2020230129222932.png){width=50%}

## 6.8 switch语句
实现switch跳转指令序列的两个方法：
1. 创建一个对照关系表。表中的每一个关系都包含了一个常量值和相应语句代码的标号，当值的个数超过10个时，更高效的方式是为这些值构造一个散列表；
2. 如果表达式的值位于某个较小的范围内，比如从min到max，并且不同常量值的总数接近max - min，那么我们可以构造一个包含max - min个桶的数组，其中j - min包含了对应于值j的语句的标号；任何没有被填入对应标号的桶中包含了默认标号。

## 6.9 过程的中间代码
本节用 函数 表示带有返回值的过程
举个例子，f是一个从整数到整数的函数，赋值语句如下：
`n = f(a[i]);`
可以被翻译成如下的三地址代码：
```C
t1 = i * 4;
t2 = a[t1];
param t2;
t3 = call f, 1;
n = t3;
```

