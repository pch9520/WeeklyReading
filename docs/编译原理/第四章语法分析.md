# 4 语法分析
## 4.1 引论
### 4.1.1 语法分析器的作用
处理文法的语法分析器大体可以分为三类：
1. 通用的；
2. 自顶向下的；
3. 自底向上的。
编译器中常用的是第二类和第三类，自顶向下的方法从语法分析树的顶部（根结点）开始向底部（叶子结点）构造语法分析树，而自底向上的方法则从叶子结点开始，逐渐向根结点方向构造。
语法分析器的输入总是按照从左向右的方式被扫描，每次扫描一个符合。

### 4.1.3 语法错误的处理
程序不同层次的错误有下面四类：
1. 词法错误（标识符、关键字和运算符拼写错误，没有在字符串文本上正确地加上引号）；
2. 语法错误（包括分号放错地方、花括号多余或丢失）；
3. 语义错误（包括运算符和运算分量之间的类型不匹配，例如返回类型为void的某个Java方法中出现了一个返回某个值的return语句）；
4. 逻辑错误（比如在一个C程序中应该使用比较运算符\=\=的地方使用了赋值运算符\=，这样的程序可能是良构的，但是却没有正确反映出程序员的意图）。
报告错误的一个常用策略：
打印出有问题的那一行，然后用一个指针指向检测到错误的地方。

### 4.1.4 错误恢复策略
常用的错误恢复策略有下列四种：
1. **恐慌模式的恢复**
   语法分析器一旦发现错误就不断丢弃输入中的符号，一次丢弃一个符号，直到找到同步词法单元集合中的某个元素为止。
   缺点：恐慌模式的错误纠正方法常常会跳过大量输入，不检查被跳过部分的其他错误
   优点：它很简单，并且保证不会进入无限循环
2. **短语层次的恢复**
   当发现一个错误时，语法分析器在余下的输入上进行局部性纠正。也就是说，它可能将余下输入的某个前缀替换为另一个串，使语法分析器可以继续分析。
   优点：可以修复任何输入串
   缺点：难以处理实际错误发生在被检测位置之前的情况
3. **错误产生式**
   在当前语言的文法中加入特殊的产生式，这些产生式能产生含有错误的构造。如果语法分析过程中使用了这些错误产生式中的一个，就检测到了一个预期内的错误。
4. **全局纠正**
   给定一个不正确的输入x和文法G，这些算法将找出一个相关串y的语法分析树，使得将x转化为y所需要的插入、删除和改变的词法单元的数量最少。优点不言而喻，可以自动指出程序员写的某些Bug，并给出建议修改意见。
   缺点：一般来说开销较大，因此这些技术当前仅具有理论价值。

## 4.2 上下文无关文法
一个上下文无关文法由终结符号、非终结符号、一个开始符号和一组产生式组成。

如果一个文法可以为某个句子生成多棵语法分析树，那么它就是二义性的。二义性就是对同一个句子有多个最左推导文法或多个最右推导文法。

## 4.3 设计文法
### 4.3.3 左递归的消除
因为自顶向下的语法分析方法不能处理左递归的文法，因此需要一个转换方法来消除左递归。
消除左递归的意思：
将A -> A$\alpha$ | $\beta$ 替换为非左递归的产生式：
A -> $\beta$ A'
A' -> $\alpha$ A' | $\epsilon$
如何转换呢？
一种方式是提取左公因子
例如：
对于每个非终结符号A，找出它的两个或多个选项之间的最长公共前缀$\alpha$ 。如果$\alpha$ $\neq$ $\epsilon$ ，即存在一个非平凡的公共前缀，那么将所有A产生式A -> $\alpha\beta_1|\alpha\beta_2|...|\alpha\beta_n|\gamma$ ，替换为
$A->\alpha$ A'|$\gamma$
$A'->\beta_1|\beta_2|...|\beta_n$

## 4.4 自顶向下的语法分析
### 4.4.1 递归下降的语法分析
算法：

```C
void A() {
    // 选择一个A产生式，A -> X_1X_2...X_k;
	for (i = 1 to k) {
		if (X_i是一个非终结符号)
			调用过程X_i();
		else if (X_i等于当前的输入符号a)
			读入下一个输入符号;
		else
			// 发生一个错误	
	}
}
```

通用的递归下降技术可能需要回溯，也就是说，它可能需要重复扫描输入。
回溯的方式不是很高效，因此人们更加倾向于基于表格的方法。

如何构造一个预测分析表?
输入：文法G
输出：预测分析表M
方法：对于文法G的每个产生式$A->\alpha$，进行如下处理：
1. 对于FIRST($\alpha$)中的每个终结符号a，将$A->\alpha$ 加入到$M[A, a]$中。
2. 如果$\epsilon$ 在FIRST($\alpha$)中，那么对于FOLLOW(A)中的每个终结符号b，将$A->\alpha$ 加入到$M[A, b]$中。如果$\epsilon$ 在FIRST($\alpha$)中，且\$在FOLLOW(A)中，也将$A-\alpha$加入到$M[A, \$]$ 中
在完成上面的操作后，如果$M[A, a]$中没有产生式，那么将$M[A, a]$ 设置为error（通常用一个空条目表示）

举个例子，对于下面这段文法：
$E->TE'$
$E'->+TE'|\epsilon$
$T->FT'$
$T'->*FT'|\epsilon$
$F->(E) | id$
按照上述方法，可以生成下列预测分析表：

| 非终结符号 | id       | +              | \*         | (        | )              | \$             |
| ---------- | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ |
| $E$        | $E->TE'$ |                |            | $E->TE'$ |                |                |
| $E'$       |          | $E'->+TE'$ |            |          | $E'->\epsilon$ | $E'->\epsilon$ |
| $T$        | $T->FT'$ |                |            | $T->FT'$ |                |                |
| $T'$       |          | $T'->\epsilon$ | $T'->*FT'$ |          | $T'->\epsilon$ | $T'->\epsilon$ |
| $F$        | $F->id$  |                |            | $F->(E)$         |                |                |

### 4.4.4 非递归的预测分析
有了预测分析表，我们就可以使用非递归的方式来进行语法分析

![非递归预测分析方式](./images/Pasted%20image%2020230115224507.png){width=50%}


语法分析器由一个程序控制。该程序考虑栈顶符号X和当前输入符号a。如果X是一个非终结符号，该分析器查询分析表M中的条目$M[X, a]$来选择一个X产生式。（这里可以执行一些附加的代码，比如构造一个语法分析树结点的代码。）否则，它检查终结符号X和当前输入符号a是否匹配。

## 4.5 自底向上的语法分析
主要介绍一个被称为移入->归约语法分析的自底向上语法分析的通用框架

### 4.5.3 移入-归约语法分析技术
移入-归约语法分析器可以采取如下四种可能的动作：
1. 移入；
2. 归约；
3. 接受；
4. 报错。
举个例子：$E=>T=>T*F=>T*id=>F*id=>id*id$
按照移入-归约分析步骤：

| 栈       | 输入       | 动作             |
| -------- | ---------- | ---------------- |
| \$       | id1\*id2\$ | 移入             |
| \$id1    | \*id2\$    | 按照$F->id$归约  |
| \$F      | \*id2$     | 按照$T-F$归约    |
| \$T      | \*id2$     | 移入             |
| \$T\*    | id2\$      | 移入             |
| \$T\*id2 | \$         | 按照$F->id$归约  |
| \$T\*F   | \$         | 按照$T->T*F$归约 |
| \$T      | \$         | 按照$E->T$归约   |
| \$E      | \$         | 接受                 |

## 4.6 LR语法分析技术介绍：简单LR技术
目前最流行的自底向上语法分析器都基于所谓的LR(k)语法分析的概念。其中，"L"表示对输入进行从左到右的扫描，"R"表示反向构造出一个最右推导序列，而k表示再做出语法分析决定时向前看k个输入符号，k=0或k=1这两种情况具有实践意义。
简单LR技术简称为**SLR**

![LR技术框架图](./images/Pasted%20image%2020230115224603.png){width=50%}


**LR语法分析器的格局：**
语法分析器的完整状态包括：它的栈和余下的输入。
LR语法分析器的格局是一个形如：
$(s_0s_1...s_m,a_ia_{i+1}...a_n\$)$的对

**LR语法分析器的行为：**
1. 如果ACTION\[$s_m,a_i$\] = 移入s，那么语法分析器执行一次移入动作；它将下一个状态s移入栈中，进入格局：
   $(s_0s_1...s_ms,a_{i+1}...a_n\$)$；
2. 如果ACTION\[$s_m,a_i$\] = 归约$A->\beta$ ，那么语法分析器执行一次归约动作，进入格局
   $(s_0s_1...s_{m-r}s,a_ia_{i+1}...a_n\$)$；
   s = GOTO\[$s_{m-r}, A$\]，在这里，语法分析器首先将r个状态符号弹出栈，使状态$s_{m-r}$位于栈顶。然后，语法分析器将s压入栈中。在一个归约动作中，当前的输入符号不会改变；
3. 如果ACTION\[$s_m,a_i$\] = 接受，那么语法分析过程完成；
4. 如果ACTION\[$s_m,a_i$\] = 报错，则说明语法分析器发现了一个语法错误，并调用一个错误恢复例程。

## 4.7 更强大的LR语法分析器

SLR和LR(1)的区别主要就是在构建CLOSURE项集时有不同的结果。
SLR构建的状态集合数量少，LR(1)多，更复杂， 因为LR(1)需要向前多看一步。
举个例子：
SLR构建的CLOSURE


![SLR构建的CLOSURE，没有多看一步](./images/Pasted%20image%2020230115223700.png){width=50%}

LR(1)构建的CLOSURE，第二个分量表示下一个输入符号为xxxxx时才进行归约。

![LR(1)构建的CLOSURE](./images/Pasted%20image%2020230115223753.png){width=70%}


LALR构建的状态数和SLR没有区别，LALR会对LR(1)中的CLOSURE状态进行压缩，比如
$I_4:C->d·,c/d$
$I_7:C->d·,\$$
基本没有区别，可以压缩成一个状态：
$I_{47}:C->d·,c/d/\$$
SLR 与 LALR 总是有相同数量的状态。比如 C 语言 SLR 和 LALR可能有几百个状态，但规范 LR(1) 可能达到上千个状态。

LALR构建的CLOSURE

![LALR构建的CLOSURE](./images/Pasted%20image%2020230115225026.png){width=70%}



