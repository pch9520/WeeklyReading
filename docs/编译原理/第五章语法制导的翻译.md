<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [5 语法制导的翻译](#5-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91)
  - [5.1 语法制导定义](#51-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E5%AE%9A%E4%B9%89)
    - [继承属性和综合属性](#%E7%BB%A7%E6%89%BF%E5%B1%9E%E6%80%A7%E5%92%8C%E7%BB%BC%E5%90%88%E5%B1%9E%E6%80%A7)
  - [5.2 SDD的求值顺序](#52-sdd%E7%9A%84%E6%B1%82%E5%80%BC%E9%A1%BA%E5%BA%8F)
    - [属性求值的顺序](#%E5%B1%9E%E6%80%A7%E6%B1%82%E5%80%BC%E7%9A%84%E9%A1%BA%E5%BA%8F)
  - [5.3 语法制导翻译的应用](#53-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E7%9A%84%E5%BA%94%E7%94%A8)
  - [5.4 语法制导的翻译方案（SDT）](#54-%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%9A%84%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88sdt)
    - [从SDT中消除左递归](#%E4%BB%8Esdt%E4%B8%AD%E6%B6%88%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92)
    - [实现L属性的SDD](#%E5%AE%9E%E7%8E%B0l%E5%B1%9E%E6%80%A7%E7%9A%84sdd)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 5 语法制导的翻译
语法制导翻译的方法是先构造一棵语法分析树，然后通过访问这棵树的各个结点来计算结点的属性值。

## 5.1 语法制导定义
语法制导定义（SDD）是一个上下文无关文法和属性及规则的结合。
属性和文法符号相关联，而规则和产生式相关联。
属性可以有多种类型，比如数字、类型、表格引用或串。这些串甚至可能是很长的代码序列，比如编译器使用的中间语言的代码。
### 继承属性和综合属性
非终结符号包含两种属性：
1. 综合属性；
2. 继承属性。
结点N上的继承属性不能通过N的子结点上的属性值来定义，但是我们允许结点N上的一个综合属性通过结点N本身的继承属性来定义。
终结符号可以具有综合属性，但是不能有继承属性。

对于同时具有继承属性和综合属性的SDD，不能保证有一个顺序来对各结点上的属性进行求值。
比如 产生式`A -> B`，对于非终结符号，它们分别具有综合属性A.s和继承属性B.i，该产生式具有下列规则：

```C
A.s = B.i;
B.i = A.s + 1
```

这些规则是循环定义的，但是存在一个SDD的有用子类，可以保证每棵语法分析树都存在一个求值顺序。

## 5.2 SDD的求值顺序
依赖图被用来确定一棵给定的语法分析树中各个属性值实例的求值顺序。
依赖图描述了某个语法分析树中的属性实例之间的信息流。从一个属性实例到另一个实例的边表示计算第二个属性实例时需要用到第一个属性实例的值。
举个例子，对于产生式$E -> E_1 + T$，语义规则为$E.val = E_1.val + T.val$
对于每个使用了这个产生式的语法分析树，该树的依赖图中有一部分如下图所示：

![依赖图举例](./images/Pasted%20image%2020230128215434.png){width=60%}

上图中，虚线为语法分析树对应的边，实线为依赖图对应的边。

### 属性求值的顺序
依赖图刻画了对一棵语法分析树中不同结点上的属性求值时可能采取的顺序。如果依赖图中有一条从结点M到结点N的边，那么要先对M对应的属性求值，再对N对应的属性求值。因此，所有的可行求值顺序就是满足下列条件的结点顺序$N_1、N_2、N_3、...、N_k$：如果有一条从结点$N_i$到$N_j$的依赖图的边，那么$i < j$。这样的排序将一个有向图变成了一个线性排序，这个排序称为这个图的拓扑排序。
如果这个图中存在任意一个环，那么就不存在拓扑排序。

SDD分为：
1. S属性的，指一个SDD的每个属性都是综合属性，那么它就是S属性的，可以通过后序遍历进行翻译，适合自底向上的语法分析过程；
2. L属性的，这类SDD的思想是在一个产生式体所关联的各个属性之间，依赖图的边总是从左到右，而不能从右到左，适合自顶向下的语法分析过程。
包含下列产生式和规则的SDD既不是S属性，也不是L属性的。
产生式：$A -> B C$
语义规则：

```C
A.s = B.b;
B.i = f(C.c, A.s)
```

1. 因为第二个规则定义了一个继承属性B.i，因此整个SDD不可能是S属性的；
2. 因为属性C.c用来定义B.i，并且C在产生式体中位于B的右边，虽然在L属性的SDD中可以使用语法分析树中的兄弟结点的属性，但这些结点必须位于被定义属性的符号的左边。

## 5.3 语法制导翻译的应用
数组类型的语法制导的翻译：
当语法分析树的结构和输入的抽象语法树的结构不同时，继承属性会很有用。继承属性可以用来将信息从语法分析树的一部分传递到另一部分。

![数组类型的语法制导的翻译](./images/Pasted%20image%2020230128233624.png){width=60%}

上图中，在产生式$T -> BC$对应的根结点上，非终结符号C使用继承属性C.b从B那里继承类型。在最右边的C结点上的产生式是$C -> \epsilon$ ，因此$C.t$等于$C.b$。产生式$C->[num]C_1$ 的语义规则将运算符array作用到运算分量$num.val$和$C_1.t$上，得到$C.t$的值。

## 5.4 语法制导的翻译方案（SDT）
动作可以放置在产生式体的任何位置上。当一个动作左边的所有符号都被处理过后，该动作立刻执行。
- 如果语法分析过程是自底向上的，那么我们在X的此次出现位于语法分析栈的栈顶时，我们立刻执行动作a；
- 如果语法分析过程时自顶向下的，那么我们在试图展开Y的本次出现（如果Y时非终结符号）或者在输入中检测Y（如果Y是终结符号）之前执行语义动作a。
任何SDT都可以按照下列方法实现：
1. 忽略语义动作，对输入进行语法分析，并产生一棵语法分析树；
2. 检查每个内部结点N，假设它的产生式是$A->\alpha$。将$\alpha$中的各个动作当作N的附加子结点加入，使得N的子结点从左到右和$\alpha$中的符号及动作完全一致；
3. 对这棵语法树进行前序遍历，并且当访问到一个以某个动作为标号的结点时立刻执行这个动作。

![一棵加入动作的语法分析树](./images/Pasted%20image%2020230129001241.png){width=60%}

上图中，虚线表示需要执行的语义动作，执行结果为：$+ * 354$

### 从SDT中消除左递归
消除左递归的技巧是对两个产生式$A -> A\alpha|\beta$进行替换，可以被替换为下面的产生式：
$A -> \beta R$
$R -> \alpha R|\epsilon$

![消除一个后缀SDT的左递归](./images/Pasted%20image%2020230129002841.png){width=60%}

### 实现L属性的SDD
- 用递归下降语法分析实现L属性的SDD：如果我们有一个L属性定义，且其基础文法可以用自顶向下的方法进行语法分析，我们就可以构造出一个不带回溯的递归下降语法分析器来实现这个翻译。继承属性变成了非终结符号对应的函数的参数，而综合属性由该函数返回
- 实现LL文法之上的L属性的SDD：每个以LL文法为基础文法的L属性定义可以在语法分析过程中实现。用于存放一个非终结符号的综合属性的记录被放在栈中这个非终结符号之下，而一个非终结符号的继承属性和这个非终结符号存放在一起。栈中还放置了动作记录，以便在适当的时候计算属性值
