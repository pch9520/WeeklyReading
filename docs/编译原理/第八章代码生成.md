# 8 代码生成

代码生成器的作用：
将中间代码（三地址代码、树、DAG图）转化为目标程序。

## 8.1 代码生成器设计中的问题

### 代码生成器的输入
代码生成器的输入是编译器前端生成的中间表示（IR）和相关的符号表信息
IR的中间表示形式的选择有很多，包括：
1. 四元式、三元式、间接三元式等三地址表示方式；
2. 字节代码和堆栈机代码的虚拟机的表示方式；
3. 后缀表示的线性表示方式；
4. 语法树和DAG图形表示形式。

### 目标程序
构造一个能够产生高质量及其代码的代码生成器的难度会受到目标机器的指令集体系结构的极大影响。
常见的目标及体系结构：
1. RISC（精简指令集计算机）；
2. CISC（复杂指令集计算机）；
3. 基于堆栈的结构。

目标程序可以是：
1. 一个使用绝对地址的机器语言程序；
2. 一个可重定位的机器语言程序；
3. 一个汇编程序。

本章内容使用的搭配是：一个简易RISC目标机 + 汇编代码

### 指令选择
对于一个给定的三地址构造，还需要有关该构造所在上下文的信息才能决定哪个才是最好的机器代码序列。

指令选择可以使用：
1. 树模式匹配优化生成的机器指令；
2. 动态规划优化生成的机器指令。

### 寄存器分配
主要解决的问题是变量放在哪个寄存器中。

### 求值顺序
计算执行的顺序会影响目标代码的效率。

## 8.3 目标代码中的地址
程序再逻辑地址空间运行，这个空间被划分成为四个代码及数据区域：
1. 一个静态确定的代码区Code。这个区存放可执行的目标代码；
2. 一个静态确定的静态数据区。这个区存放全局变量和编译器生成的其他数据；
3. 一个动态管理的堆区。存放程序运行时刻分配和释放的数据对象；
4. 一个动态管理的栈区。存放过程的活动记录。

### 静态分配

主要关注下面的三地址语句：
1. call callee（调用某个方法），通过BR指令实现；
2. return（控制返回到另一段程序），通过BR指令实现；
3. halt（将控制返回给操作系统），通过HALT指令实现；
4. action（一段三地址代码的占位符）。

假设我们有下面的三地址代码：
```C
           // c的代码    
action;
call p;
           // p的代码

action2;
halt;

action3
return
```

![静态分配的目标代码](./images/Pasted%20image%2020230226221211.png){width=50%}

### 栈分配
如果再保存活动记录时使用相对地址，静态分配就可以变成栈分配。
但是在栈分配方式中，只有等到运行时刻才能知道一个过程的活动记录的位置。
这个位置一般存放在一个寄存器中。


### 名字的运行时刻地址
存储分配策略以及过程的活动记录中局部数据的布局决定了如何访问名字对应的内存位置。
我们假设一个三地址语言中的名字实际上是一个指向该名字的符号表条目的指针。
在任何一种情况下，名字最终必须被替代为访问存储位置的代码。

举个例子：
x的符号表条目包含了x的相对地址12，如果x被分配在一个从地址static开始的静态分配区域中，那么x的实际运行时刻地址是static + 12。
赋值语句`x = 0`被翻译成：
`static[12] = 0`，如果静态区从地址100开始，这个语句的目标代码是：

```C
LD 112, #0
```

## 8.4 基本块和流图

上下文信息有助于更好地生成代码。
如果我们知道程序中的值是如何被定值和使用，我们就可以更好地分配寄存器。

将中间代码划分为基本块，有助于更好地分配寄存器。

### 基本块
基本块是指满足下列条件的最大的连续三地址指令序列：
1. 控制流只能从基本块中的第一个指令进入该块。也就是说，没有跳转到基本块中间的转移指令；
2. 除了基本块的最后一个指令，控制流在离开基本块之前不会停机或跳转。

判断是否为基本块首指令的规则：
1. 中间代码的第一个三地址指令是一个首指令；
2. 任意一个条件或无条件转移指令的目标指令是一个首指令；
3. 紧跟在一个条件或无条件转移指令之后的指令是一个首指令。

下面这个中间代码，指令1、2、3、12、13为首指令

![某个中间代码](./images/Pasted%20image%2020230226223551.png){width=50%}

### 流图

上图8-7可以生成的流图

![基于上图构建的流图](./images/Pasted%20image%2020230226223457.png){width=50%}

上图中，有三个循环：
1. {$B_3$}；
2. {$B_6$}；
3. {$B_2, B_3, B4$}。

## 8.5 基本块的优化

这里指的是对各个基本块本身进行局部优化。

### 基本块的DAG表示
很多重要的局部优化技术首先把一个基本块转换成为一个DAG

为下面的基本块构建DAG图，如下图所示：
```Python
a = b + c;
b = a - d;
c = b + c;
d = a - d;
```

![某个基本的DAG图](./images/Pasted%20image%2020230226224057.png){width=50%}

可以采用的优化方法：
1. 消除局部公共子表达式，即消除重复计算的一个已经计算得到值的指令；
2. 消除死代码，即消除不会再被使用的指令；
3. 代数优化

对于第3点：
可以将一个代价较高的代数运算替换为一个代价较低的计算而不影响计算结果。
如：
$x^2$  -> $x * x$
$2 * x$ -> $x + x$
$x / 2$ -> $x * 0.5$

## 8.6 一个简单的代码生成器

### 寄存器和地址描述符

变量的新值可能已经在寄存器中计算出来但还没有存放到内存中。这个数据结构具有下列描述符：
1. 每个可用的寄存器都有一个寄存器描述符，用来跟踪有哪些变量的当前值存放在此寄存器中。在开始时所有的寄存器描述符都是空的，随着代码运行，每个寄存器中将存放0个或多个变量名字的值；
2. 每一个程序变量都有一个地址描述符。它用来跟踪记录在哪个或哪些位置上可以找到该变量的当前值，这个位置可以是一个寄存器、一个内存地址、一个栈中的位置，也可以是**这些位置组成的一个集合**。

### 代码生成算法

就是将三地址代码转化为汇编语言的算法。这个算法一个重要的函数是`getReg(I)`
`I`是指三地址指令。

`getReg(I)`用来为指令选择对应的寄存器
规则大致原理为：
1. 尽可能复用原来的寄存器；
2. 使用某个空的寄存器；
3. 如果没有空闲的寄存器，就选择一个代价最小的寄存器，先把里面的变量复制到内存中，再将需要计算的变量放入该寄存器中。



