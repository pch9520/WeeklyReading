<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [7 运行时刻环境](#7-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%BB%E7%8E%AF%E5%A2%83)
  - [7.1 存储组织](#71-%E5%AD%98%E5%82%A8%E7%BB%84%E7%BB%87)
  - [7.2 空间的栈式分配](#72-%E7%A9%BA%E9%97%B4%E7%9A%84%E6%A0%88%E5%BC%8F%E5%88%86%E9%85%8D)
    - [活动记录](#%E6%B4%BB%E5%8A%A8%E8%AE%B0%E5%BD%95)
    - [栈中的变长数据](#%E6%A0%88%E4%B8%AD%E7%9A%84%E5%8F%98%E9%95%BF%E6%95%B0%E6%8D%AE)
  - [7.3 栈中非局部数据的访问](#73-%E6%A0%88%E4%B8%AD%E9%9D%9E%E5%B1%80%E9%83%A8%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AE%BF%E9%97%AE)
    - [访问链](#%E8%AE%BF%E9%97%AE%E9%93%BE)
    - [显示表](#%E6%98%BE%E7%A4%BA%E8%A1%A8)
  - [7.4 堆管理](#74-%E5%A0%86%E7%AE%A1%E7%90%86)
    - [一台计算机的存储层次结构](#%E4%B8%80%E5%8F%B0%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84)
    - [程序中的局部性](#%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%B1%80%E9%83%A8%E6%80%A7)
  - [7.5 垃圾回收](#75-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)
    - [垃圾回收器的设计目标](#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87)
  - [7.6 基于跟踪的回收的介绍](#76-%E5%9F%BA%E4%BA%8E%E8%B7%9F%E8%B8%AA%E7%9A%84%E5%9B%9E%E6%94%B6%E7%9A%84%E4%BB%8B%E7%BB%8D)
    - [基本的标记-清扫式算法](#%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%A0%87%E8%AE%B0-%E6%B8%85%E6%89%AB%E5%BC%8F%E7%AE%97%E6%B3%95)
    - [Baker的标记-清扫式回收器](#baker%E7%9A%84%E6%A0%87%E8%AE%B0-%E6%B8%85%E6%89%AB%E5%BC%8F%E5%9B%9E%E6%94%B6%E5%99%A8)
    - [标记并压缩的垃圾回收器](#%E6%A0%87%E8%AE%B0%E5%B9%B6%E5%8E%8B%E7%BC%A9%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8)
    - [拷贝回收器](#%E6%8B%B7%E8%B4%9D%E5%9B%9E%E6%94%B6%E5%99%A8)
  - [7.7 短停顿垃圾回收](#77-%E7%9F%AD%E5%81%9C%E9%A1%BF%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 7 运行时刻环境
编译器必须准确地实现源程序语言中包含的各个抽象概念。如名字、作用域、绑定、数据类型、运算符、过程、参数以及控制流的构造。

为了做到这一点，编译器创建并管理一个运行时刻环境。
这个环境处理很多事务，包括为在源程序中命名的对象分配和安排存储位置，确定目标程序访问变量时使用的机制，过程间的连接，参数传递机制以及与操作系统、输入输出设备及其他程序的接口。

## 7.1 存储组织
代码区：通常位于存储的低端；
静态区：包括全局变量和编译器产生的数据；
堆栈区：动态的，一般在剩余地址空间的两端，栈区向低地址生长，堆向高地址生长。

![运行时刻内存被划分成代码区和数据区的典型方式](./images/Pasted%20image%2020230212184006.png){width=50%}

## 7.2 空间的栈式分配

### 活动记录
过程调用和返回通常由一个称为控制栈的运行时刻栈进行管理。
每个活跃的活动都有一个位于这个控制栈中的活动记录（有时也被称为帧，frame）。
活动树的根位于栈底，栈中全部活动记录的序列对应于在活动树中到达当前控制所在的活动结点的路径。
程序控制所在的活动记录位于栈顶。

| 元素           | 解释                                                                                                                                                                                                       |
| -------------- | ---------------------------------------------------------------------------------- |
| 临时值         | 当表达式求值过程中产生的中间结果无法存放在寄存器中时，就会生成这些临时值                                                                                                                                   |
| 局部数据       | 对应于这个活动记录过程的局部数据                                                                                                                                                                           |
| 保存的机器状态 | 包括对此过程的此次调用之前的机器状态信息。这些信息通常包括返回地址（程序计数器的值，被调用过程必须返回到该值所指位置）和一些寄存器中的内容（调用过程会使用这些内容，被调用过程必须在返回时恢复这些内容）。 |
| 访问链         | 当被调用过程需要其他地方（比如另一个活动记录）的某个数据时需要使用访问链进行定位                                                                                                                           |
| 控制链         | 指向调用者（上一个function）的活动记录                                                                                                                                                                     |
| 返回值         | 用于存放被调用函数的返回值。这个值一般倾向于放置到一个寄存器中以提高效率                                                                                                                                   |
| 实在参数       | 调用过程使用的实参，这些值通常放在寄存器中，但仍为它们预留了相应的空间，使我们的活动记录具有完全的通用性                                                                                                                                                                                                           |

![一个概括性的活动记录](./images/Pasted%20image%2020230212204707.png){width=50%}

### 栈中的变长数据
一般而言，在编译时刻不能决定大小的对象将被分配在堆区。
但也可以将未知大小的对象、数组以及其他结构分配在栈中。
将对象放置在栈中可以避免对它们的空间进行垃圾回收。
只有一个数据对象局限于某个过程，且当此过程结束时它变得不可访问，才可以使用栈为这个对象分配空间。

如下图所示，图中给出了一个被p调用的过程q的活动记录，q的这个活动记录从p的数组之后开始，q的所有变长数组被分配在q的活动记录之外。

![访问动态分配的数组](./images/Pasted%20image%2020230212203617.png){width=50%}

## 7.3 栈中非局部数据的访问

### 访问链

针对嵌套函数的通常的静态作用域规则的一个直接实现方法是在每个活动记录中增加一个被称为访问链的指针。

如果过程p在源代码中直接嵌套在过程q中，那么p的任何活动中的访问链都指向最近的q的活动。

p和q的定义：
p -> 快排算法中的partition函数
q -> 快排算法中的quicksort函数

沿着访问链找到的活动就是其数据和对应过程可以被当前正在运行的过程访问的所有活动。

![用来查找非局部数据的访问链](./images/Pasted%20image%2020230212210449.png){width=50%}

### 显示表

使用访问链的方法来访问非局部数据的问题之一是，如果嵌套深度变大，就必须沿着一段很长的访问链路才能找到需要的数据。一个更高效的实现方法是使用一个称为显示表的辅助数组d。辅助数组d为每个嵌套深度保存了一个指针。$d[i]$ 指向栈中最高的对应于某个嵌套深度为i的过程的活动记录。

使用显示表的优势在于，如果过程p正在运行，且它需要访问属于某个过程q的元素x，那么我们只需要查看$d[i]$ 即可。其中，i是q的嵌套深度。我们沿着指针$d[i]$ 找到q的活动记录，根据已知的偏移量就可以在这个活动记录中找到x。编译器知道i的值，因此它可以产生代码，该代码根据$d[i]$ 和x相对于q的活动记录顶部的偏移量来访问x。因此，该代码不需要经过一段很长的访问链路。

## 7.4 堆管理

### 一台计算机的存储层次结构

![典型的内存层次结构的配置](./images/Pasted%20image%2020230212212053.png){width=50%}

### 程序中的局部性

时间局部性：一个程序访问的存储位置很可能将在一个很短的时间段内被再次访问。

空间局部性：被访问过的存储位置的临近位置很可能在一个很短的时间段内被访问。

通常认为程序把90%的时间用来执行10%的代码。

## 7.5 垃圾回收

### 垃圾回收器的设计目标

增变者：用户程序，它会修改堆区的对象集合。

某个语言适合进行垃圾回收的一个基本要求：类型安全。

类型安全的语言：可以在编译时刻或运行时刻确定类型的语言，例如：Java

类型不安全的语言：该语言既不是静态类型安全的，也不是动态类型安全的，就被称为类型不安全的语言。例如：C和C++

对于类型不安全的语言来说，一个程序可以在任何时候引用内存中的任何位置。没有哪个内存位置可以被认为是不可访问的，也就无法安全地回收任何存储空间。

垃圾回收器一般有两类：
1. 通过判断可达性进行回收的垃圾回收器；
2. 通过引用计数进行回收的垃圾回收器。

## 7.6 基于跟踪的回收的介绍

其实就是通过可达性判定和广度优先搜索，实现垃圾回收。

主要介绍了四类算法：
1. 基本的标记-清扫式算法；
2. Baker的标记-清扫式算法；
3. 基本的标记并压缩算法；
4. Cheney的拷贝回收器。

### 基本的标记-清扫式算法

这是一种直接的全面停顿的算法。它们找出所有不可达的对象，并将它们放入空闲空间列表，然后清扫**整个堆区**并释放不可达对象

### Baker的标记-清扫式回收器

找出不可达对象不再需要遍历整个堆区。
为了找出不可达对象的集合，我们可以求已分配对象和可达对象之间的差集即可。

### 标记并压缩的垃圾回收器

进行重新定位的垃圾回收器会在堆区内移动可达对象以消除存储碎片。
将所有对象放在一段连续的位置上可以减少内存空间的碎片，使得它更容易存储较大的对象。
同时，通过使数据占用更少的缓存线和内存页，重新定位可以提高程序的时间局部性和空间局部性。

存在两种进行重新定位的回收器：
1. 在本地进行重新定位，可以降低存储需求，但速度相对较慢（标记并压缩的垃圾回收器）；
2. 在重新定位之前预留了一部分空间（拷贝回收器），更高效、更流行。

![标记并压缩的垃圾回收器](./images/Pasted%20image%2020230212215529.png){width=50%}

### 拷贝回收器

拷贝回收器预先保留了可以将对象移入的空间，因而解除了跟踪和发现空闲空间之间的依赖关系。

整个存储空间被划分为两个半空间（semispace）A和B。增变者在半空间之一（比如A）内分配内存，直到它被填满。此时**增变者停止**，垃圾回收器将可达对象拷贝到另一个半空间，比如说B。

## 7.7 短停顿垃圾回收

基于简单跟踪的回收器是以全面停顿的方式进行垃圾回收的，它可能造成用户程序的运行的长时间的停顿。我们可以每次只做部分垃圾回收工作，从而减少一次停顿的长度。

短停顿垃圾回收有两种：
1. 增量式回收：按照时间来分割清扫工作任务，使垃圾回收和增变者的运行交错进行；
2. 部分回收：按照空间来分割工作任务，每次只完成一部分垃圾的回收。









